hoj 1867 经理的烦恼   
此题是最基本的一维树状数组题目，直接进行简单的加一减一（通过判素）操作即可。
hoj 2430 Counting the algorithms     
从后往前不断删除（这样的话不存在区间包含问题），统计相同元素区间内数的个数。之后将这两个元素一起删除。
hoj 1640 Mobile Phone     
该题目是典型的二维树状数组的题目。
hoj 2275 Number sequence      
题目就是统计序列中Ai < Aj > Ak（i < j < k）的个数，可以从前往后统计每个元素之前小于它的数的个数，在从后往前统计每个元素之后小于它的数的个数。然后乘积加和即可。注意树状数组统计是起始为1。
poj 2352 Stars         
相当经典的树状数组题目，一开始分析题目是第一感觉是二维的树状数组，不过数据范围显然不容许的，可先排序，然后再统计每个位置之前的星星的个数。
poj 3067 Japan         
与stars极其相似，唯一的不同是上题诗统计之前的个数，而这个统计之后的个数，当然我们可以用当前总数i减去之前的数即可得到。此题bt之处在于不能用long long 只能用__int64。
poj 2155 Matrix        
此题是二维树状数组基本应用的变通，不像hoj1640简单的插入统计，而此题是对一个二维区间数值翻转（0变1，1变0），最后询问某处的值。所以可以使用奇偶性判断，这样我们可以使用树状数组在这个二维区间内加，就相当于翻转，最后统计某点翻转的次数。
poj 3321 Apple Tree        
首先进行DFS遍历一遍，对每个节点编号（进入递归时begin[i],出递归时end[i]，具体见《算法导论》），由于子树的编号是连在一起的，同时包含在子树的的根begin[root]和end[root]之间，所以以后可以直接利用树状数组对其内容修改和统计。
hoj 2098 poj 2299 Ultra-QuickSort
该题是求逆序数的题目，当然我们可以使用合并排序法，在此介绍一种用树状数组解决的方法，由于元素的范围巨大，可以先采用离散化（就是排序编号），然后依次查值，并统计当前比自己大的元素的个数（当前总数-小于等于自己），即可得到结果，和以上的Japan有着相似的处理方法。
